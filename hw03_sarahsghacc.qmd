---
title: "WebSraping-SQL"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo       = TRUE, 
                      fig.align  = "center",
                      fig.height = 3, fig.width = 4)
ggplot2::theme_set(ggplot2::theme_bw() + ggplot2::theme(strip.background = ggplot2::element_rect(fill = "white")))
```

## Instructions

Complete the following exercises using the appropriate packages in R. Ensure that your solutions are optimized and use functional programming principles where applicable.

1.  Load the necessary libraries.
2.  Answer each question in separate R code chunks.
3.  Provide detailed explanations for your approach.
4.  Submit the rendered HTML file.

```{r}
  if (!require("pacman")) install.packages("pacman")

# Load contributed packages with pacman
pacman::p_load(
  pacman,       # Package management
  rvest,        # Web scraping
  dplyr,        # Data manipulation
  tidyverse,    # Tidy data tools
  xml2,         # Parse HTML/XML
  janitor,      # Clean column names, etc.
  DBI,          # Database interface
  duckdb,       # Embedded SQL database
  nycflights13  # Flight dataset
)
```

```{r}
# Load the necessary packages explicitly
library(DBI)
library(duckdb)

# Create the database directory if needed
if (!dir.exists("data")) dir.create("data")

# Connect to the DuckDB database
practcon <- dbConnect(duckdb::duckdb(), dbdir = "data/practcon.duckdb", read_only = FALSE)

```

```{r}
if (!dir.exists("data")) dir.create("data")
practcon <- dbConnect(duckdb::duckdb(), dbdir = "data/practcon.duckdb", read_only = FALSE)

dbIsValid(practcon)
```

```{r}
if (!"flights" %in% dbListTables(practcon)) {
  dbWriteTable(practcon, "flights", nycflights13::flights)
}

if (!"airlines" %in% dbListTables(practcon)) {
  dbWriteTable(practcon, "airlines", nycflights13::airlines)
}
```

In this code chunk, we use the `pacman` package to efficiently load all required libraries in a single line with `p_load()`. This approach avoids repeatedly calling `library()` and will install any missing packages automatically. We also load `nycflights13` for working with flight data in later questions.

**Detailed explanation for approach:** Using the `pacman` package with `pacman::p_load()` is an efficient way to manage and load multiple R packages at once. This function checks whether each package is installed and, if not, installs it automatically before loading it. This approach eliminates the need for repetitive `library()` calls. It also improves reproducibility and consistency across different environments, which is especially useful when sharing code or switching between machines. By loading all necessary packages at the beginning, we ensure that the rest of the analysis can run without interruption.

## WebScraping

### Problem 1:

Go to the following page [List of U.S. states and territories by population](https://en.wikipedia.org/wiki/List_of_U.S._states_and_territories_by_population) and select the table `State and territory rankings`.

1.  Make sure the name of columns and the first row is correct\
2.  Make sure the class of each column is correct\
3.  Replace `__` with `NA`\

```{r}
# Step 1: Read the Wikipedia page and extract all tables
url <- "https://en.wikipedia.org/wiki/List_of_U.S._states_and_territories_by_population"

tables <- url |>
  read_html() |>
  html_table(fill = TRUE)

# Extract the first table
raw_table <- tables[[1]]

# Step 1: Load and clean
state_table <- raw_table |>
  clean_names() |>            # Make column names syntactic (no duplicates)
  slice(-1) |>                # Remove first row (repeated headers)
  mutate(across(everything(), str_trim)) |>    # Trim all whitespace
  mutate(across(everything(), ~ na_if(.x, "__")))  # Convert "__" to NA

# Step 2: Convert all columns *except the first one* to numbers
# This handles commas, $, %, etc.
state_table <- state_table |>
  mutate(across(-1, readr::parse_number))  # parse_number keeps only digits & decimals

# Step 3: Optional: Rename for clarity (so you know what these weird names mean)
names(state_table)[1:6] <- c(
  "state",
  "pop_2024",
  "pop_2020",
  "pct_change_2010_2020",
  "abs_change_2010_2020",
  "house_seats"
)

# Preview cleaned data
head(state_table)

```

**Detailed explanation for approach:** To clean and prepare the table from Wikipedia, I first extracted all tables using `html_table()` and selected the first one, which contains population data. The first row, which duplicated the headers, was removed with `slice(-1)`. I then used `mutate(across(...))` to trim whitespace from all columns and convert placeholder values `"__"` into `NA`s using `na_if()`. Next, I converted all non-name columns to numeric using `readr::parse_number()`, which handles formatting like commas and symbols. Finally, I renamed the first few columns to clear, meaningful labels for readability and previewed the cleaned data with `head()` to confirm that the structure and types were appropriate.

## SQL

Please download a duck database. <https://data-science-master.github.io/lectures/data/flights.duckdb>

-   Use `duckdb()` and `DBI::dbConnect()` to create a connection to "flights.duckdb".

```{r}

# Connect to the DuckDB file
practcon <- dbConnect(duckdb(dbdir = "data/practcon.duckdb"), read_only = FALSE)
```

```{r}
if (!"flights" %in% DBI::dbListTables(practcon)) {
  DBI::dbWriteTable(practcon, "flights", nycflights13::flights)
}
```

-   `dbConnect()`: This function establishes a connection to a database.

-   `duckdb()`: Specifies you are connecting to a DuckDB database, which is an embedded analytical SQL database.

-   `dbdir = "flights.duckdb"`: This tells DuckDB to store the database in a file called flights.duckdb. If the file doesn't exist, it will be created.

-   `read_only = FALSE`: This means you are allowing the database to be modified. If you set this to TRUE, the database would be read-only, meaning you could only query data but not make changes to it.

-   So, setting `read_only = FALSE` is necessary if you want to add, update, or delete data in the database.

-   You can see the object `practcon` in the "Global Environment" indicating the connection profile has been established to the database.

-   Check is the connection has established

```{r}
dbIsValid(practcon)
```

Please note that a basic SQL code chunk looks like this (put SQL code between the chunks):

```{r, echo = FALSE, comment = ""}
    codechunk <- "```{sql, connection=con}\n\n```"
    writeLines(codechunk)
```

```{r}
# Write the flights table only if it doesnâ€™t exist
if (!"flights" %in% dbListTables(practcon)) {
  dbWriteTable(practcon, "flights", nycflights13::flights)
}
if (!"airlines" %in% dbListTables(practcon)) {
  dbWriteTable(practcon, "airlines", nycflights13::airlines)
}
library(DBI)
library(duckdb)
practcon <- dbConnect(duckdb::duckdb(), dbdir = "data/practcon.duckdb", read_only = FALSE)
```

```{r}
dbIsValid(practcon)
```

```{sql connection=practcon, echo=TRUE}
SELECT f.*
FROM flights AS f
JOIN airlines AS a
  ON f.carrier = a.carrier
WHERE a.name = 'United Air Lines Inc.';
```

Print out a summary of the tables in this database.

```{sql, connection=practcon, echo=FALSE, eval=FALSE}
    DESCRIBE;
```

-   Answer the following question using SQL.

### Problem 2: Select Flights from a Specific Carrier

Write a SQL query to find all flights from the carrier "United Air Lines Inc.".

```{r}
if (!"airlines" %in% DBI::dbListTables(practcon)) {
  DBI::dbWriteTable(practcon, "airlines", nycflights13::airlines)
}

```

```{sql connection=practcon, echo=TRUE}
SELECT f.*
FROM flights AS f
JOIN airlines AS a
  ON f.carrier = a.carrier
WHERE a.name = 'United Air Lines Inc.';
```

**Detailed explanation for approach:** To find all flights operated by "United Air Lines Inc.", I first ensured the `airlines` table was available in the DuckDB environment by writing it from the `nycflights13` package using `dbWriteTable()`. Then, I used an SQL `JOIN` to link the `flights` table with the `airlines` table by matching the `carrier` codes in both. This allowed me to access the full airline names stored in the `airlines` table. In the `WHERE` clause, I filtered the results to include only those rows where the airline name is "United Air Lines Inc.". The query returns all flight records from the `flights` table that correspond to this specific carrier.

### Problem 3: Count the Number of Flights for Each Carrier

Write a SQL query to count the total number of flights for each carrier.

```{sql connection=practcon, echo=TRUE}
SELECT carrier, COUNT(*) AS num_flights
FROM flights
GROUP BY carrier;
```

## Remember to Close the connection When You Are Done

-   if the connection is open then you need to use `dbDisconnect()` function

## Submission

-   Save your Quarto file after completing each problem, render it, then stage and commit the changes.\

-   Include well-commented code and clear explanations.\

-   Make at least **one commit per question**.\

-   Submit the rendered file to **Canvas** and push it to your **GitHub repository**.\

-   Provide the link to your GitHub repository in the **Canvas gradebook** as a text submission.\

ðŸ”¹ **Problem 1 is worth 40 points, and Problems 2 and 3 are each worth 20 points.**\

ðŸ”¹ You will receive an additional **20 points** if you correctly push your completed file to GitHub and make at least one commit for each problem.\

**Good luck!**
